{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "bc736648",
   "metadata": {},
   "source": [
    "Subset_finding is a modul in shapiq_student which allows to compute the set of x features of an InteractionValues object which have the highest or lower shapley value. The following Jupyter Notebook explains the different algorithms used to determine the set and showcases how to use them."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0ab1eb0c",
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys, os\n",
    "\n",
    "sys.path.append(os.path.abspath(\"..\"))\n",
    "import shapiq_student.coalition_finding as cf"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3e7cb443",
   "metadata": {},
   "source": [
    "Importing the subset_finding module."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "22d865a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "from shapiq import ExactComputer\n",
    "from shapiq.games.benchmark import SOUM"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d26a63a1",
   "metadata": {},
   "source": [
    "Importing modules from shapiq used to generate InteractionValues to showcase the subset_finding module on."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c3412e72",
   "metadata": {},
   "outputs": [],
   "source": [
    "game = SOUM(n=5, n_basis_games=100)\n",
    "computer = ExactComputer(n_players=game.n_players, game=game)\n",
    "Interaction_Values = computer(index=\"FSII\", order=3)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d20b54b4",
   "metadata": {},
   "source": [
    "This generates InteractionValues using functions from shapiq."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e6a77e9a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{(): 0.8188664227426776,\n",
       " (0,): 0.1640937022012522,\n",
       " (1,): -0.40398748802120926,\n",
       " (2,): -0.5056002071191349,\n",
       " (3,): -2.8614891699074887,\n",
       " (4,): -0.029946596700750432,\n",
       " (0, 1): -0.6315173070901232,\n",
       " (0, 2): -1.1349814390343986,\n",
       " (0, 3): -0.3020736331570433,\n",
       " (0, 4): -0.3269094226237127,\n",
       " (1, 2): -0.1992231439062453,\n",
       " (1, 3): -1.215209124121748,\n",
       " (1, 4): -0.3761106695116966,\n",
       " (2, 3): -0.5200689548248226,\n",
       " (2, 4): -1.176454989554101,\n",
       " (3, 4): -0.7249340770501714,\n",
       " (0, 1, 2): 0.017345413078240685,\n",
       " (0, 1, 3): -0.38551689784130483,\n",
       " (0, 1, 4): 0.5295082184972789,\n",
       " (0, 2, 3): -0.16281549970094236,\n",
       " (0, 2, 4): 0.5295082185056167,\n",
       " (0, 3, 4): 0.01636871094341243,\n",
       " (1, 2, 3): 0.584371912275799,\n",
       " (1, 2, 4): 0.6224009337095094,\n",
       " (1, 3, 4): -0.3843970941726946,\n",
       " (2, 3, 4): 1.7614543973266574}"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Interaction_Values.dict_values"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "093dfd6a",
   "metadata": {},
   "source": [
    "This is an example for the Shapley Values in an InteractionValues object with 5 features. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1f04d0c0",
   "metadata": {},
   "source": [
    "To determine the coalition of x features with the largest or smallest combined value multiple different algorithms can be used. In this example our coalition will include 3 features."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "00f58f84",
   "metadata": {},
   "outputs": [],
   "source": [
    "brute_force_output = cf.brute_force(Interaction_Values, 3)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d8abaf24",
   "metadata": {},
   "source": [
    "A simple but slow way is to use a brute force approach to check every possible coalition and return the smallest and largest."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e9676d08",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "InteractionValues(\n",
      "    index=FSII, max_order=3, min_order=0, estimated=True, estimation_budget=None,\n",
      "    n_players=5, baseline_value=0.8188664227426776,\n",
      "    Top 10 interactions:\n",
      "        (): 0.8188664227426776\n",
      "        (0, 1, 4): -0.2560031405062835\n",
      "        (1, 3, 4): -5.177207796743081\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "print(brute_force_output)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fa60707c",
   "metadata": {},
   "source": [
    "This way the output is guranteed to be correct at the downside of significant runtime."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "34f42409",
   "metadata": {},
   "source": [
    "In the subset_finding module there are three more algorithms implemented, each with their different accuracy and runtime.\n",
    "Every function is called with the InteractionValues object and the number of features in the coalition."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3e205269-ac07-4529-b6f0-1e0fb23244f8",
   "metadata": {},
   "source": [
    "## Greedy Coalition Method\n",
    "\n",
    "The `greedy_coalition` method selects features one-by-one by always choosing the one that locally improves the coalition value the most (or the least for minimization). This is a fast heuristic method.\n",
    "\n",
    "Below, we demonstrate its usage:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a32ebfa4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "InteractionValues(\n",
      "    index=FSII, max_order=3, min_order=0, estimated=True, estimation_budget=None,\n",
      "    n_players=5, baseline_value=0.8188664227426776,\n",
      "    Top 10 interactions:\n",
      "        (): 0.8188664227426776\n",
      "        (0, 1, 4): -0.2560031405062835\n",
      "        (1, 3, 4): -5.177207796743081\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "greedy_output = cf.greedy_coalition(Interaction_Values, 3)\n",
    "print(greedy_output)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "673b8413-e41f-4cb0-af76-e0874d45fcf4",
   "metadata": {},
   "source": [
    "## Beam Search Coalition Method\n",
    "\n",
    "The `beam_search_coalition` method performs a breadth-limited search through possible coalitions. At each step, it retains only the top `beam_width` best partial coalitions, which makes it more robust than greedy but still efficient.\n",
    "\n",
    "Below, we demonstrate its usage:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "539e4aa3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "InteractionValues(\n",
      "    index=FSII, max_order=3, min_order=0, estimated=True, estimation_budget=None,\n",
      "    n_players=5, baseline_value=0.8188664227426776,\n",
      "    Top 10 interactions:\n",
      "        (): 0.8188664227426776\n",
      "        (0, 1, 4): -0.2560031405062835\n",
      "        (1, 3, 4): -5.177207796743081\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "beam_search_output = cf.beam_search_coalition(Interaction_Values, 3)\n",
    "print(beam_search_output)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "082ec194-e475-4c87-bebd-84799da01c7a",
   "metadata": {},
   "source": [
    "## Beam Search Coalition Method with specified beam_width\n",
    "\n",
    "To customize the beam_width, one can use '`beam_search_coalition_call`' as demonstrated below:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d771efe2-120a-4ed6-9930-a9a51e2afaa4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "InteractionValues(\n",
      "    index=FSII, max_order=3, min_order=0, estimated=True, estimation_budget=None,\n",
      "    n_players=5, baseline_value=-1.9944612118945846,\n",
      "    Top 10 interactions:\n",
      "        (1, 3, 4): -1.2029500754229137\n",
      "        (): -1.9944612118945846\n",
      "        (0, 2, 4): -5.42441447603113\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "beam_search_call_output = cf.beam_search_coalition_call(Interaction_Values, 3, beam_width=10)\n",
    "print(beam_search_call_output)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40314fab",
   "metadata": {},
   "source": [
    "## Recursive greedy algorithm\n",
    "\n",
    "The recursive greedy algorithm splits the features into candidates for the maximum and minimum coalition based on their first order Shapley Value. Then for every candidate is recursively computes the best candidates to be in the coalition with them based on their shared Shapley Values. For every potential member added to the coalition a smaller fraction of next candidates is checked until for the last member of the coalition only the best candidate is selected."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d658bea7",
   "metadata": {},
   "outputs": [],
   "source": [
    "recursive_greedy_output = cf.recursive_greedy_coalition(Interaction_Values, 3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9be33084",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "InteractionValues(\n",
      "    index=FSII, max_order=3, min_order=0, estimated=True, estimation_budget=None,\n",
      "    n_players=5, baseline_value=-1.0798937315685124,\n",
      "    Top 10 interactions:\n",
      "        (3, 2, 4): -0.6822053214857471\n",
      "        (): -1.0798937315685124\n",
      "        (1, 2, 0): -5.466691693392462\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "print(recursive_greedy_output)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8a08b4fb",
   "metadata": {},
   "source": [
    "An advantage of the recursive greedy algorithm is that the maximum and minimum coalition has to be computed seperatly which means that either can be accessed on its own in less runtime if only one is needed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0ddeff2a",
   "metadata": {},
   "outputs": [],
   "source": [
    "recursive_greedy_min_output = cf.recursive_greedy_min_coalition(Interaction_Values, 3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "16199741",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "InteractionValues(\n",
      "    index=FSII, max_order=3, min_order=0, estimated=True, estimation_budget=None,\n",
      "    n_players=5, baseline_value=-1.0798937315685124,\n",
      "    Top 10 interactions:\n",
      "        (): -1.0798937315685124\n",
      "        (1, 2, 0): -5.466691693392462\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "print(recursive_greedy_min_output)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7b77c631",
   "metadata": {},
   "outputs": [],
   "source": [
    "recursive_greedy_max_output = cf.recursive_greedy_max_coalition(Interaction_Values, 3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "27d3cfab",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "InteractionValues(\n",
      "    index=FSII, max_order=3, min_order=0, estimated=True, estimation_budget=None,\n",
      "    n_players=5, baseline_value=-1.0798937315685124,\n",
      "    Top 10 interactions:\n",
      "        (3, 2, 4): -0.6822053214857471\n",
      "        (): -1.0798937315685124\n",
      ")\n"
     ]
    }
   ],
   "source": [
    "print(recursive_greedy_max_output)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
